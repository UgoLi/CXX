回顾：
1 类的定义和实例化
1）class、struct
2）访问控制属性：public、private
3）构造函数
4）对象的创建和销毁
类名 对象名(...);
类名* 对象指针名 = new 类名();
5）多文件编程

2 构造函数
1）可以重载、缺省参数、哑元参数
2）缺省（无参）构造函数
eg:
class A{
public:
    A(void){...}
};
class B{
public:
    B(void){...}
    int m_i;
    A m_a;
};
3）类型（单参）转换构造函数（关键字：explicit必须显示）
4）拷贝构造函数
    类名(const 类名& that){...}
    class A{
        A(cosnt A& that){...}
    };
    A a1;
    A a2 = a1;//A a2(a1);

============================================================
今天：
十四 构造函数和初始化表
...
5 初始化表
1）语法形式 见：01initlist.cpp
    class 类名{
        类名（形参表）:成员变量1（初值），...{}
    };
    int a=100;
    -------------------------
    int a;
    a = 100;
2）必须要使用初始化表的场景
--》如果有类 类型的成员变量，而该类又没有无参构造函数，则必须通过初始化表
来初始化该成员变量。

--》类中包含"const"和"引用"成员变量，必须在初始化表中显示的初始化。

int a;
a=100;

==========================================================
十五 this指针与常函数
1 this指针 见：06this.cpp
1）类的成员函数、构造函数中都有一个隐藏的类 类型指针参数，名为this。
--》对于普通的成员函数，this指针就是指向调用该函数的对象
--》对于构造函数，this指针指向正在被创建的对象

2）需要显示使用this指针的场景
--》区分作用域,见：07this.cpp
--》从成员函数返回调用对象的自身
//cout.func<<(a)
cout<<a<<b<<endl;   见：08this.cpp (重点掌握)

--》从类的内部销毁对象自身

2 常成员函数(常函数) 见：09constfunc.cpp
1）在一个普通成员函数后面加上const关键字，这个成员函数就称为常函数。
返回值 函数名(形参表) const {函数体}
2）常函数中的this指针是个常指针，不能在常函数中修改成员的值。

注：被mutable关键字修饰的成员变量可以在常函数中被修改。
eg:
    void func(int* pi){...}
    int main(void){
        const int a=100;
        func(&a);//&a-->const int*,调用函数的形参也要是const int* 类型
    }
================================================
3）非 常对象既可以调用常函数也能调用非 常函数；
   常对象只能调用常函数，不能调用非常函数。见：10constfunc.cpp

4）函数名和形参表相同的成员函数，其常版本和非常版本构成函数重载，
常对象调用常版本，非 常对象调用非 常版本。 见：11constfunc.cpp

-----------------------------------------------
十六 析构函数(Destructor)
1 语法形式 见：12destructor.cpp
class 类名{
public:
    ~类名(void){//清理对象在创建时分配的动态资源}
};
1）函数名必须是"~类名"
2）没有返回类型，也没有参数，不能被重载。
3）主要负责 清理对象在创建时分配的动态资源

2 当对象被销毁时，析构函数将被自动执行 见：13destructor.cpp
1）栈对象当其离开作用域时，其析构函数被作用域终止的右花括号"}"调用。
2）堆对象的析构函数被delete运算符调用。

3 如果一个类没有显示的调用析构函数，那么编译器会为该类提供一个缺省的
析构函数；
--》对基本的成员变量什么也不做
--》对类 类型的成员变量，会调用相应的析构函数 见：14destructor.cpp

4 对向的创建和销毁
1）对象的创建
--》分配内存
--》构造成员子对象
--》执行构造函数代码
2）对象的销毁
--》执行析构函数代码
--》析构成员子对象
--》释放内存

======================================================================
十七 拷贝构造和拷贝赋值
见：15copy.cpp
1 浅拷贝和深拷贝
1）如果一个类中包含指针形式的成员变量，缺省的拷贝构造函数只是复制了指针
变量本身，而没有复制指针所指向的内容，这种拷贝称为浅拷贝。
2）浅拷贝将导致不同对象之间的数据共享，如果数据存放在堆区，可能会在析构时
引发“double free”异常，因此就需要自己定义一个支持复制指针所指向内容的拷贝
构造函数，称为深拷贝。

练习：自己实现String类，支持深拷贝构造
class String{
public:

    String(const char* str="")//构造函数
    :m_str(strcpy(new char[strlen(str)+1],str))
    {
        /*
        m_str=new char[strlen(str)+1];
        strcpy(m_str,str);
        */
    }

    //析构函数
    ~String(void){
        delete[] m_str;
        m_str=NULL;
    }

    //深拷贝函数

private:
    char* m_str;
}
