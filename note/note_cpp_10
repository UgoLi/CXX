
二十二 多态(Polymorphic)
1 函数重写(虚函数覆盖)、多态概念
    如将基类中的某个成员函数声明为虚函数，那么子类与其具有相同原型的成员函数就也将是
虚函数，并且对基类中的版本形成覆盖。
    这时，通过指向基类对象的基类指针，或者引用子类对象的基本引用，调用该虚函数，实际
被执行的将是子类中覆盖版本，而不是基类中的原始版本，这中语法现象称为多态。

2 函数重写要求(函数覆盖条件)
1）类中普通的成员函数可以声明为虚函数，而全局函数、类中的静态成员函数、构造函数都不能
声明为虚函数。
 注：析构函数可以成为虚函数(后面将)
2）只有在基类中以virtual关键字修饰的函数，才能作为虚函数被子类覆盖，而与子类中virtual
关键字无关。
3）虚函数在子类中的覆盖版本和该函数在基类中原始版本要拥有相同的函数签名，即函数、形参
表、常属性必须严格一致。
3）如果基类中的虚函数返回基本类型的数据，那么子类的覆盖版本必须返回相同的类型。
5）如果基类的虚函数返回类类型指针(A*)或引用(A&)，那么允许子类返回其子类类型的指针(B*)
和引用(B&)。--类型协变 

3 多态的条件
1）在满足虚函数覆盖前提下，必须要通过指针或引用调用该虚函数，才能表现出来。
2）调用虚函数的指针也可以是this指针，只要他是一个指向子类对象的基类指针，调用虚函数
时，同样可以表现出多态的特性。//重点掌握

4 純虚函数、抽象类和純抽象类
1）純虚函数
    virtual 返回类型 函数名(形参表)[const]=0;
2）如果一个类中包含純虚函数，那么这个类就是抽象类。抽象类不能创建对象。

3）純抽象类(有名接口类)
    如果一个抽象类除了构造函数和析构函数以外所有成员函数都是純虚函数，
那么该类就是純抽象类。

注：如果子类没有覆盖抽象类的純虚函数，那么该子类就也是一个抽象类，类的抽象属性可以被
继承。

5 多态的实现原理
 通过虚函数表和动态绑定，参考poly.jpg
1）动态绑定会增加内存的开销
2）虚函数调用会增加时间开销
3）虚函数不能被内联优化
注：如果没有多态的语法要求，最好不要使用虚函数。

6 虚析构函数
1）基类析构函数不能调用子类的析构函数，对一个指向子类的对象的基类指针使用delete运算符，
实际被执行的仅是基类的析构函数，所释放的仅是基类子对象构造时的分配的动态资源，而子类
特有的动态资源将会形成内存泄漏。
2）将基类的析构函数声明为虚函数，那么子类的析构函数就也是一个虚构函数，并且可以对基类
的虚析构函数形成有效的覆盖，可以表现多态特性。
3）这时delete是一个指向子类对象的基类指针，实际被调用的将是子类的析构函数，而子类的析构
函数在执行后又会自动调用基类的析构函数，避免内存泄漏。



