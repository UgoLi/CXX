
二十 操作符重载
1 双目操作符

1.1 运算类的双目操作符

1）成员函数形式
------------------------------------------------------
2）全局函数形式    见：01complex.cpp
L#R的表达式会被编译器自动处理为operator#(L,R)的全局调用函数，
该函数的返回值，即为表达式的值

注：通过friend关键字，可以把一个全局函数声明为某个类的友元，友元函数
可以访问类中的任何成员

-------------------------------------------------------
1.2 赋值类的双目操作符 见：02complex.cpp
-->做操作数是左值(不能是常量)，右操作数可以是左值也可以是右值
-->表达式的结果是左值，就是做操作数的自身
1）成员函数形式：L#R--》L.operator#(R);
2）全局函数形式：L#R--》operator#(L,R);
(a=b)=c;
-------------------------------------------------------
2 单目操作符 #O   见：03integer.cpp
2.1 计算类单目操作符:-(取负) ~ !
--》操作数可以是左值也可以是右值
--》表达式的结果是一个右值
1）成员函数形式
    #O--》O.operator#();
2）全局函数形式
    #O--> operator#(O);

int a=100;
-a;//结果是临时变量,右值
-a=200;//语法错误
-------------------------------------------------------
2.2 自增减单目操作符:++/--
1）前缀的自增减
--》操作数是左值
--》表达式的结果就是操作数的自身，也是左值

成员函数形式：#O-->O.operator#();
全局函数形式：#O-->operator#(O);

2）后缀的自增减
--》操作数是左值
--》表达式的结果是自增减之前的副本(右值) ？？
成员函数形式：O#--》O.operator#(int/*哑元*/)
全局函数形式：O#--》operator#(O,int/*哑元*/)

-------------------------------------------------------
3 插入和提取操作符：<< >>  见：05io_operator.cpp
注：只能用全局函数形式

功能：实现自定义类型的输入和输出的功能


#include<iostream>
ostream cout;
istream cin;

cout<<a;//operator<<(cout,a)
friend ostream& operator<<(ostream& os,const TYPE& a){...}

cin>> a;//operator>>(cin,a);
friend istream& operator>>(istream& is,TYPE& a);
===========================================================
练习：实现3x3矩阵类，支持如下操作符重载 见：06complex.cpp 
+ - += -= -(取负) ++ -- <<
class M33{
public:
    M33(void){
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                m_a[i][j]=0;
    }
    M33(int a[][3]){
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
                m_a[i][j]=a[i][j];
    }
privat:
    int m_a[3][3];
};

4 new/delete 操作符  见：07complex.cpp
static void* operator new(size_t size){...}
static void operator delete(void* p){..}


