回顾：
1 bool类型
2 操作符别名
3 C++的函数
1）函数重载//extern "c"
2) 缺省参数 定义：void func(int a/*=10*/){...}
            声明：void func(int a=10);或 void func (int =10);
            注：缺省参数右侧的参数也应该全是缺省参数。
3）哑元参数：void func(int),定义时只有类型名，占据一个位置，但并没有使用这个参数。
4）内联函数：inline 将函数加载到代码段内存，以空间换时间。
             内联优化:inline只是建议编译器以内联方式优化，具体编译器选择
             如，递归函数就不会被优化。
4 动态内存分配 new/delete   new[]/delete[]
5 C++引用 
1）引用即别名：类型 & 引用名 = 变量名
2）常引用（万能引用）
3）关注左值和右值

今天
十 c++的引用
1
2
3 引用型函数（常用）
1)将引用用于函数的参数，可以修改实参变量的值，同时也能减小函数调用的开销。
2)引用参数有可能意外修改实参的值，如果不希望修改是参数的变量本身，可以将其定义为常引用，
    提高传参效率的同时还可以接受常亮型的实参。

4 引用型函数返回值
1）语法上可以将函数的返回值声明为引用，避免函数返回值所带来的开销。
2）如果一个函数的返回值类型被声明为引用，那么这个函数返回值可以是一个左值。
3）为了避免在函数的外部修改引用的目标，可以为该属性附加常属性。
eg:
    const int& foo(void){
        static int a=100;
        return a;
    }
    int main(void){
        foo()=200;//err
    }
注：不要返回局部变量的引用，所引用的目标内存会在函数返回以后被释放，危险！
但是可以返会成员、静态局部变量的引用。

//笔试题：引用和指针的区别...
5 引用和指针
1)从c语言角度，引用的本质就是指针，但c++中推荐使用引用而不是指针。
eg:
    double d=3.14;
    double re=d;
    double* const pd=&d;
    rd<=等价=>*pd
2)指针定义可以不初始化，其目标可以修改（指针常量除外）；
    而引用必须初始化，而且一旦初始化所引用的目标不能再改变。
eg:
    int a-3,b=5;
    int* p;//ok
    //int& r;//err
    p=&a;
    p=&b;
    int& r=a;
    r=a;//不是修改引用的目标，而是对r(a)进行复制。
//后面了解
3）可以定义的指针的指针，但是不能定义引用的指针
eg:
    int a=100;
    int* p=&a;
    int* * pp=&p; 

    int& r=a;
    int& * pr=&r;//err
    int* pr=&r;//ok,是一个普通的指针
4）可以定义指针的引用，但是不能定义引用的引用
eg:
    int a=100;
    int* p=&a;
    int* & rp=p;//ok,指针的引用
    ---------------------------------------
    int& r=a;
    int&& rr=r;//err,在c++11中称为右值引用
    int& r2=r;//ok,不能称为引用的引用，只是一个普通的引用，相当于给a再起一个别名。

5）可以定义指针数组，但是不能定义引用数组
eg:
    int a=1,b=2,c=3;
    int* parr[3]={&a,&b,&c};
    int& rarr[3]={a,b,c};//err
6）可以定义数组引用
eg:
    int arr[3]={1,2,3};
    //rarr称为数组引用，给数组起一个别名
    int (& rarr)[3]=arr;
    arr[0]<-等价->rarr[0]
7）和函数指针一样，可以定义函数引用，语法和函数指针一致。
eg:
    void func(int a,int b){..}
    int main(void){
        //定义和使用函数指针
        void (*pfunc)(int,int)=func;
        pfunc(10,20);
        //定义和使用函数引用
        void (&rfunc)(int,int)=func;
        rfunc(10,20);
    }

十一 类型转换
1 隐式类型转换
eg:
    char c='A';
    int n=c;//隐式类型转换
    -----------------------------
    void foo(int n){...}
    foo(c);//隐式类型转换
    -----------------------------
    void foo(void){
        char c='A';
        return c;//隐式类型转换
    }
    -----------------------------
    int& r=c;//err
    const int& r=c;//ok

2 强制类型转换
eg:
    char c='A';
    int n=(int)c;//C style
    int n=int(c);//C++ style

3 c++增加了四种操作符形式的显式类型转换
1）静态类型转换
语法:
    目标类型变量=static_cast<目标类型>(源类型变量)
适用场景:用于将void* 转化为其他类型的指针
eg:
    int a=100;
    void* pv=&a;//ok
    int* pi=pv;//err
    int* pi=static_cast<int*>(pv);//ok

2）动态类型转换(后面讲)
语法:
    目标类型变量=dynamic_cast<目标类型>(源类型变量)；

3）常类型转换
语法:
    目标类型变量=const_cast<目标类型>(源类型变量)；
使用场景:用于去除一个指针或引用的常属性
eg:
    int a=100;
    const int* pa=&a;
    *pa=200;//err
    int* pa2=const_cast<int*>(pa);
    const inti& r=a;
    r=200;//err
    int& r2=const_cast<int&>(r);
    r2=300;//ok

4）重解释类型转换

语法:
    目标类型变量=reinterpret_cast<目标类型>(源类型变量)；
适用场景:
    -->任意类型的指针或引用之间的转换
    -->在指针和整数之间的转换
    eg:
        int addr=0x12345678
        int* p=reinterpret_cast<int*>(0x12345678);
        *p=100;

======================================================
小结:
1 慎用宏，用const、enum、inline替换
#define PAI 3.14 --》const double PAI = 3.14 

#define STATE_SLEEP 0
#define STATE_RUN1
#define STATE_STOP  2
--》enum STATE{SLEEP,RUN,STOP};

#define max(a,b) ((a)>(b)?(a):(b))
--> inline int max(int a,int b){
        return a > b ? a : b;
    }
2 变量随用随声明同时初始化

3 尽量使用new/delete分配，取代malloc/free

4 少用void*、指针计算、联合体、强制转换

5 尽量使用string表示字符串，少用C中的char*表示的字符串

====================================
十二 类和对象//了解
1 什么是对象？
    万物皆对象，任何一种事物都可以看做是对象。

2 如何描述对象？
    通过对象的属性(名词、数量词、形容词)和行为(动词)描述和表达对象。
      
3 面向对象的程序设计
    对自然世界中对象观察引入到编程实践的一种理念和方法。
    这种方法称为"数据抽象",即在描述对象时把细节的东西剥离出去，
    只考虑一般性的，有规律性的和统一性的东西。
         
4 什么是类?
    类是将多个对象的共性提取出来定义的一种新的数据类型，
    是对 对象的属性和行为的抽象描述。
            
练习：
    复习前面内容(重点看第八、十章节) 
    预习 十三章 类的定义和实例化



