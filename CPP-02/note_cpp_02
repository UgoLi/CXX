六 c++的布尔类型
1 bool类型是C++基本类型，专门表示逻辑值：true/false

2 bool在内存上占一个字节：1表示true，0表示false

3 bool类型可以接受任意类型寒表达式的结果，其值非0则为true，值为0则为false
NULL--》（void*）0

七 操作符别名 （了解）
&& --》and
|| --》or
{  --》<%
}  --》%>

八 C++函数
1 函数的重载
char *strcpy(char *dest, const char *src);
char *strcpy(char *dest, const char *src, size_t n);
1）定义
    在相同的作用域，定义相同名的函数，但是他们的参数表必须有所区分，这样的函数构成重载关系。
    注：重载和函数返回类型无关
2）函数重载匹配
    调用重载关系函数，编译器根据实参与形参匹配程度，自动选择最优的重载版本
    完全匹配>常量转换>升级转换>降级转换>省略号匹配
3）函数重载原理
 C++编译器通过换名，将参数表的信息整合到新的函数名中，实现解决重载函数与名字冲突的矛盾

笔试题：函数声明中加入 extern "C"作用？
要求C++编译器不对函数做命名倾轧，便于c程序调用该函数;

2 函数的缺省参数
socket(,,0)
send(,,,0)
1）可以为函数的部分参数和全部参数指定缺省值，调用该函数，如果不给实参，就取缺省值作为相应的形参值。
eg:
    void func(int a,int b,int flag=0){...}
    int main(void){
        func(10,20,1);
        func(10,20);
    }
2）缺省参数必须靠右，如果一个参数有缺省值，那么这个参数的右侧所有参数都必须有缺省值。
3）如果函数的定义和声明分开，缺省参数应该写在函数的声明部分，而定义部分不写。

3 函数的哑元参数
1）定义：只有类型而没有变量名的形参称为哑元
eg:
    void func(int a,int /*哑元*/){}
2）使用哑元的场景
--》为了兼容旧代码
算法库：
    void math_func(int a,int b){...}
使用者：
    int main(void){
        math_func(10,20);
        ...
        math_func(20,30);
    }
-------------------------------------------
升级算法库：
    void math_func(int a,int=0/*哑元*/){...}

--》操作符重载时 区分前后++/--（后面讲）

4 內联函数（inline）
//inline关键字的作用
1）定义
    使用inline关键字修饰的函数，表示这个函数是内联函数，编译器将尝试做內联优化，避免函数调用的开销，
    提高代码的执行效率。
2）适用场景
--》多次调用的小而简单的函数适合内联
--》调用次数极少 或者 大而复杂的函数不适合內联
--》递归函数不适合內联
注：只是一种建议而不是强制要求，能否內联主要取决于编译器，有些函数不加inline关键字修改也会被默认处理为
    內联，有些即便加了也会被忽略。
--------------------------------------------------
笔试题：
1）代码片段1
for(int i=0;i<100000;i++)
    for(int j=0;j<100;j++)
        ...
2）代码片段2
for(int i=0;i<100;i++)
    for(int j=0;j<100000;j++)
        ...
--------------------------------------------------

九 C++的动态内存分配
//笔试题：C++中new/delete和c中的malloc和free区别
1 回顾C中动态分配
1）分配：malloc()/calloc()/realloc()
2) 释放：free()
3）错误：返回值
eg:
    int* pi=(int *)malloc(sizeof(int));
    *p = 100;
    free(p);//避免泄露
    p=NULL;//避免使用野指针

2 C++使用运算符分配动态内存
1）分配：new、new[]
2）释放：delete、delete[]
3）错误处理：异常(后面讲)
eg:
    //int* p=new int;//分配不初始化
    //*p = 100;
    int* p=new int(100);//分配同时初始化
    delete p;
    p=NULL;
    -------------------------------------
    int* parr=new int[10];//分配数组
    parr[0]=10;
    parr[1]=20;
    ...
    delete[] parr;
    parr=NULL;

十 C++的引用（Reference）
1 定义
1）引用就是某个变量的别名，对引用的操作与对该变量的操作完全相同。
2）语法规则
    类型 & 引用名 = 变量名;
    注：引用在定义时必须初始化，而且初始化以后不能修改引用的目标。
    注：引用的类型和它所绑定的目标变量的类型要一致。
eg:
    int a = 10;
    int& b = a;//b就是a的别名
    b++;
    cout << a << endl;//11
    int c=20;
    b=c;//将c的值赋值给b(a)
    cout << a << endl;//20
2）常引用
1）定义引用时加const修饰，即为常引用，不通过常引用修改引用的目标。
eg：
    int a=10;
    const int& b=a;//b就是a的常引用
    b=200;//err
2）普通引用只能引用左值
    常引用也称万能引用，既能左值也能右值。
================================================
注：关于左值和右值
1）左值：可以放在赋值运算符的左侧。
--》普通变量都是左值
--》前++/--表达式结果是左值
--》赋值表达式的结果是左值
eg:
    int a = 1;
    ++a=20;//ok
    cout << a << endl;//20
    ++++++a;
    cout << a << endl;//23
eg:
    int a=3,b=5;
    int c=0;
    (c=a)=b;//ok
    cout << c << endl;//5
2）右值：只能放在赋值运算符右侧
--》字面值常量
--》大多数的表达式的值
eg:
    int a=3,b=5;
    (a+b)=10;//err,a+b的结果是右值
--》函数返回值
eg:
    int foo(void){
        int a=100;
        return a;
    }
    int main(void){
        int res=foo();
        cout << res <<endl;//100000
        int& r=foo();//err
        const int& rc=foo();//ok
        return 0;
    }









